package main2;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.FlowLayout;
import java.awt.Frame;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.swing.AbstractCellEditor;
import javax.swing.ButtonGroup;
import javax.swing.DefaultCellEditor;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.SwingConstants;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;

/**
 * New Actions Editor for Items with checkbox-based UI
 * Shows all conditions with use checkboxes, current values, result values, and process execution
 */
public class NewItemActionsEditorDialog extends JDialog {

    private Item item;
    private String actionName;
    private JTable conditionsTable;
    private ConditionsTableModel tableModel;
    private JCheckBox filterCheckbox;

    public NewItemActionsEditorDialog(Frame owner, Item item, String actionName) {
        super(owner, "Actions Editor - " + actionName, true);
        this.item = item;
        this.actionName = actionName;

        initUI();
        loadExistingActions();

        setSize(900, 600);
        setLocationRelativeTo(owner);
    }

    private void initUI() {
        setLayout(new BorderLayout(10, 10));

        // Top panel with filter and manage conditions button
        JPanel topPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        filterCheckbox = new JCheckBox("Zeige nur aktuell zugewiesene Conditions");
        filterCheckbox.addActionListener(e -> applyFilter());
        topPanel.add(filterCheckbox);

        JButton manageConditionsBtn = new JButton("Manage Conditions");
        manageConditionsBtn.addActionListener(e -> openConditionsManager());
        topPanel.add(manageConditionsBtn);

        add(topPanel, BorderLayout.NORTH);

        // Table with conditions
        tableModel = new ConditionsTableModel();
        conditionsTable = new JTable(tableModel);
        conditionsTable.setRowHeight(30);

        // Set up column widths
        conditionsTable.getColumnModel().getColumn(0).setPreferredWidth(200); // Conditions
        conditionsTable.getColumnModel().getColumn(1).setPreferredWidth(60);  // use
        conditionsTable.getColumnModel().getColumn(2).setPreferredWidth(200); // if Current Value
        conditionsTable.getColumnModel().getColumn(3).setPreferredWidth(150); // Result Value
        conditionsTable.getColumnModel().getColumn(4).setPreferredWidth(200); // Result Process

        // Set up custom renderers and editors
        conditionsTable.getColumnModel().getColumn(1).setCellRenderer(new CheckBoxRenderer());
        conditionsTable.getColumnModel().getColumn(1).setCellEditor(new CheckBoxEditor());

        conditionsTable.getColumnModel().getColumn(2).setCellRenderer(new IfCurrentValueRenderer());
        conditionsTable.getColumnModel().getColumn(2).setCellEditor(new IfCurrentValueEditor());

        conditionsTable.getColumnModel().getColumn(3).setCellRenderer(new RadioButtonRenderer());
        conditionsTable.getColumnModel().getColumn(3).setCellEditor(new RadioButtonEditor());

        conditionsTable.getColumnModel().getColumn(4).setCellEditor(new DefaultCellEditor(new JTextField()));

        JScrollPane scrollPane = new JScrollPane(conditionsTable);
        add(scrollPane, BorderLayout.CENTER);

        // Bottom panel with buttons
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));

        JButton saveBtn = new JButton("Save");
        saveBtn.addActionListener(e -> saveActions());
        buttonPanel.add(saveBtn);

        JButton cancelBtn = new JButton("Cancel");
        cancelBtn.addActionListener(e -> dispose());
        buttonPanel.add(cancelBtn);

        add(buttonPanel, BorderLayout.SOUTH);
    }

    private void loadExistingActions() {
        // Load all available conditions
        Set<String> allConditions = Conditions.getAllConditionNames();

        // Load existing actions for this item and actionName
        Map<String, ConditionRow> existingRows = loadExistingActionsFromFile();

        // Add all conditions to table
        for (String conditionName : allConditions) {
            ConditionRow row;
            if (existingRows.containsKey(conditionName)) {
                row = existingRows.get(conditionName);
            } else {
                row = new ConditionRow(conditionName);
            }
            tableModel.addRow(row);
        }
    }

    private Map<String, ConditionRow> loadExistingActionsFromFile() {
        Map<String, ConditionRow> rows = new HashMap<>();

        File actionsFile = new File("resources/actions/" + item.getName() + ".txt");
        if (!actionsFile.exists()) {
            return rows;
        }

        try {
            List<String> lines = Files.readAllLines(actionsFile.toPath());

            for (int i = 0; i < lines.size(); i++) {
                String line = lines.get(i).trim();

                if (line.startsWith("#" + actionName + ":")) {
                    // Parse action line
                    String content = line.substring(actionName.length() + 2).trim();

                    // Split into condition and result parts
                    String[] parts = content.split("->");
                    if (parts.length == 2) {
                        String conditionsStr = parts[0].trim();
                        String resultsStr = parts[1].trim();

                        // Parse conditions (could be multiple with AND)
                        String[] conditions = conditionsStr.split("&&");

                        // Parse results
                        String processName = "";
                        Map<String, Boolean> resultValues = new HashMap<>();

                        String[] results = resultsStr.split("\\|\\|");
                        for (String result : results) {
                            result = result.trim();

                            if (result.startsWith("#SetBoolean:")) {
                                String boolStr = result.substring(12).trim();
                                String[] boolParts = boolStr.split("=");
                                if (boolParts.length == 2) {
                                    String condName = boolParts[0].trim();
                                    boolean value = Boolean.parseBoolean(boolParts[1].trim());
                                    resultValues.put(condName, value);
                                }
                            } else if (result.startsWith("#Process:")) {
                                processName = result.substring(9).trim();
                            }
                        }

                        // Create rows for each condition in this action
                        for (String cond : conditions) {
                            cond = cond.trim();
                            String[] condParts = cond.split("=");
                            if (condParts.length == 2) {
                                String condName = condParts[0].trim();
                                String condValue = condParts[1].trim();

                                ConditionRow row = new ConditionRow(condName);
                                row.use = true;
                                row.ifCurrentValue = condValue; // "true" or "false"

                                // Set result value if this condition has one
                                if (resultValues.containsKey(condName)) {
                                    row.resultValue = resultValues.get(condName);
                                }

                                // Set process name (only on first condition)
                                if (conditions[0].trim().equals(cond)) {
                                    row.processName = processName;
                                }

                                rows.put(condName, row);
                            }
                        }
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        return rows;
    }

    private void applyFilter() {
        // Reapply filter by reloading table with filter logic
        tableModel.setFilterUnused(filterCheckbox.isSelected());
    }

    private void saveActions() {
        // Collect all used conditions
        List<ConditionRow> usedRows = new ArrayList<>();
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            ConditionRow row = tableModel.getRow(i);
            if (row.use) {
                usedRows.add(row);
            }
        }

        if (usedRows.isEmpty()) {
            // Remove this action if no conditions are used
            removeActionFromFile();
            JOptionPane.showMessageDialog(this, "Action removed (no conditions used)", "Saved", JOptionPane.INFORMATION_MESSAGE);
            dispose();
            return;
        }

        // Build action string
        StringBuilder conditionsStr = new StringBuilder();
        StringBuilder resultsStr = new StringBuilder();
        String processName = "";

        for (int i = 0; i < usedRows.size(); i++) {
            ConditionRow row = usedRows.get(i);

            // Skip conditions with "ignore" - they don't participate in the condition check
            if (!"ignore".equals(row.ifCurrentValue)) {
                // Add condition
                if (conditionsStr.length() > 0) {
                    conditionsStr.append(" && ");
                }
                conditionsStr.append(row.conditionName).append("=").append(row.ifCurrentValue);
            }

            // Add result value
            if (row.resultValue != null) {
                if (resultsStr.length() > 0) {
                    resultsStr.append(" || ");
                }
                resultsStr.append("#SetBoolean:").append(row.conditionName).append("=").append(row.resultValue);
            }

            // Get process name (from first row that has one)
            if (!row.processName.isEmpty() && processName.isEmpty()) {
                processName = row.processName;
            }
        }

        // Add process to results
        if (!processName.isEmpty()) {
            if (resultsStr.length() > 0) {
                resultsStr.append(" || ");
            }
            resultsStr.append("#Process:").append(processName);
        }

        // Build final action line
        String actionLine = "#" + actionName + ":" + conditionsStr.toString() + " -> " + resultsStr.toString();

        // Save to file
        saveActionToFile(actionLine);

        JOptionPane.showMessageDialog(this, "Action saved successfully!", "Saved", JOptionPane.INFORMATION_MESSAGE);
        dispose();
    }

    private void saveActionToFile(String actionLine) {
        File actionsFile = new File("resources/actions/" + item.getName() + ".txt");

        try {
            List<String> lines = new ArrayList<>();

            // Read existing lines
            if (actionsFile.exists()) {
                lines = new ArrayList<>(Files.readAllLines(actionsFile.toPath()));
            }

            // Remove old action line for this action
            lines.removeIf(line -> line.trim().startsWith("#" + actionName + ":"));

            // Add new action line
            lines.add(actionLine);

            // Write back to file
            actionsFile.getParentFile().mkdirs();
            Files.write(actionsFile.toPath(), lines);

        } catch (IOException e) {
            e.printStackTrace();
            JOptionPane.showMessageDialog(this, "Error saving action: " + e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
        }
    }

    private void removeActionFromFile() {
        File actionsFile = new File("resources/actions/" + item.getName() + ".txt");

        if (!actionsFile.exists()) {
            return;
        }

        try {
            List<String> lines = new ArrayList<>(Files.readAllLines(actionsFile.toPath()));
            lines.removeIf(line -> line.trim().startsWith("#" + actionName + ":"));
            Files.write(actionsFile.toPath(), lines);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Table Model
    class ConditionsTableModel extends AbstractTableModel {
        private List<ConditionRow> rows = new ArrayList<>();
        private List<ConditionRow> filteredRows = new ArrayList<>();
        private boolean filterUnused = false;
        private String[] columnNames = {"Conditions", "use", "if Current Value", "Result Value", "Result Process"};

        public void addRow(ConditionRow row) {
            rows.add(row);
            updateFilteredRows();
        }

        public ConditionRow getRow(int rowIndex) {
            return filteredRows.get(rowIndex);
        }

        public void setFilterUnused(boolean filter) {
            this.filterUnused = filter;
            updateFilteredRows();
        }

        private void updateFilteredRows() {
            filteredRows.clear();
            for (ConditionRow row : rows) {
                if (!filterUnused || row.use) {
                    filteredRows.add(row);
                }
            }
            fireTableDataChanged();
        }

        @Override
        public int getRowCount() {
            return filteredRows.size();
        }

        @Override
        public int getColumnCount() {
            return columnNames.length;
        }

        @Override
        public String getColumnName(int column) {
            return columnNames[column];
        }

        @Override
        public Object getValueAt(int rowIndex, int columnIndex) {
            ConditionRow row = filteredRows.get(rowIndex);

            switch (columnIndex) {
                case 0: return row.conditionName;
                case 1: return row.use;
                case 2: return row.ifCurrentValue;
                case 3: return row.resultValue;
                case 4: return row.processName;
                default: return null;
            }
        }

        @Override
        public void setValueAt(Object value, int rowIndex, int columnIndex) {
            ConditionRow row = filteredRows.get(rowIndex);

            switch (columnIndex) {
                case 1:
                    row.use = (Boolean) value;
                    updateFilteredRows();
                    break;
                case 2:
                    row.ifCurrentValue = (String) value;
                    break;
                case 3:
                    row.resultValue = (Boolean) value;
                    break;
                case 4:
                    row.processName = (String) value;
                    break;
            }

            fireTableCellUpdated(rowIndex, columnIndex);
        }

        @Override
        public boolean isCellEditable(int rowIndex, int columnIndex) {
            // Columns 1 (use), 2 (if current value), 3 (result value), and 4 (process) are editable
            return columnIndex == 1 || columnIndex == 2 || columnIndex == 3 || columnIndex == 4;
        }

        @Override
        public Class<?> getColumnClass(int columnIndex) {
            switch (columnIndex) {
                case 1: return Boolean.class;
                case 2: return String.class;
                case 3: return Boolean.class;
                default: return String.class;
            }
        }
    }

    // Data class for table rows
    class ConditionRow {
        String conditionName;
        boolean use = false;
        String ifCurrentValue = "ignore"; // "true", "false", or "ignore"
        Boolean resultValue = null;
        String processName = "";

        public ConditionRow(String conditionName) {
            this.conditionName = conditionName;
        }

        public boolean getCurrentValue() {
            return Conditions.getCondition(conditionName);
        }
    }

    // Custom cell renderers
    class CheckBoxRenderer extends JCheckBox implements TableCellRenderer {
        public CheckBoxRenderer() {
            setHorizontalAlignment(SwingConstants.CENTER);
        }

        @Override
        public Component getTableCellRendererComponent(JTable table, Object value,
                boolean isSelected, boolean hasFocus, int row, int column) {
            setSelected(value != null && (Boolean) value);
            return this;
        }
    }

    class IfCurrentValueRenderer extends JPanel implements TableCellRenderer {
        private JRadioButton trueButton;
        private JRadioButton falseButton;
        private JRadioButton ignoreButton;

        public IfCurrentValueRenderer() {
            setLayout(new FlowLayout(FlowLayout.CENTER, 5, 0));

            trueButton = new JRadioButton("true");
            falseButton = new JRadioButton("false");
            ignoreButton = new JRadioButton("ignore");

            ButtonGroup group = new ButtonGroup();
            group.add(trueButton);
            group.add(falseButton);
            group.add(ignoreButton);

            add(trueButton);
            add(falseButton);
            add(ignoreButton);
        }

        @Override
        public Component getTableCellRendererComponent(JTable table, Object value,
                boolean isSelected, boolean hasFocus, int row, int column) {

            String strValue = value != null ? value.toString() : "ignore";

            trueButton.setSelected("true".equals(strValue));
            falseButton.setSelected("false".equals(strValue));
            ignoreButton.setSelected("ignore".equals(strValue));

            return this;
        }
    }

    class RadioButtonRenderer extends JPanel implements TableCellRenderer {
        private JRadioButton trueButton;
        private JRadioButton falseButton;

        public RadioButtonRenderer() {
            setLayout(new FlowLayout(FlowLayout.CENTER, 5, 0));

            trueButton = new JRadioButton("true");
            falseButton = new JRadioButton("false");

            ButtonGroup group = new ButtonGroup();
            group.add(trueButton);
            group.add(falseButton);

            add(trueButton);
            add(falseButton);
        }

        @Override
        public Component getTableCellRendererComponent(JTable table, Object value,
                boolean isSelected, boolean hasFocus, int row, int column) {

            if (value == null) {
                trueButton.setSelected(false);
                falseButton.setSelected(false);
            } else {
                boolean boolValue = (Boolean) value;
                trueButton.setSelected(boolValue);
                falseButton.setSelected(!boolValue);
            }

            return this;
        }
    }

    // Custom cell editors
    class IfCurrentValueEditor extends AbstractCellEditor implements TableCellEditor {
        private JPanel panel;
        private JRadioButton trueButton;
        private JRadioButton falseButton;
        private JRadioButton ignoreButton;

        public IfCurrentValueEditor() {
            panel = new JPanel(new FlowLayout(FlowLayout.CENTER, 5, 0));

            trueButton = new JRadioButton("true");
            falseButton = new JRadioButton("false");
            ignoreButton = new JRadioButton("ignore");

            ButtonGroup group = new ButtonGroup();
            group.add(trueButton);
            group.add(falseButton);
            group.add(ignoreButton);

            panel.add(trueButton);
            panel.add(falseButton);
            panel.add(ignoreButton);
        }

        @Override
        public Component getTableCellEditorComponent(JTable table, Object value,
                boolean isSelected, int row, int column) {

            String strValue = value != null ? value.toString() : "ignore";

            trueButton.setSelected("true".equals(strValue));
            falseButton.setSelected("false".equals(strValue));
            ignoreButton.setSelected("ignore".equals(strValue));

            return panel;
        }

        @Override
        public Object getCellEditorValue() {
            if (trueButton.isSelected()) {
                return "true";
            } else if (falseButton.isSelected()) {
                return "false";
            } else {
                return "ignore";
            }
        }
    }

    class CheckBoxEditor extends DefaultCellEditor {
        private JCheckBox checkBox;

        public CheckBoxEditor() {
            super(new JCheckBox());
            checkBox = (JCheckBox) getComponent();
            checkBox.setHorizontalAlignment(SwingConstants.CENTER);
        }

        @Override
        public Component getTableCellEditorComponent(JTable table, Object value,
                boolean isSelected, int row, int column) {
            checkBox.setSelected(value != null && (Boolean) value);
            return checkBox;
        }

        @Override
        public Object getCellEditorValue() {
            return checkBox.isSelected();
        }
    }

    class RadioButtonEditor extends AbstractCellEditor implements TableCellEditor {
        private JPanel panel;
        private JRadioButton trueButton;
        private JRadioButton falseButton;

        public RadioButtonEditor() {
            panel = new JPanel(new FlowLayout(FlowLayout.CENTER, 5, 0));

            trueButton = new JRadioButton("true");
            falseButton = new JRadioButton("false");

            ButtonGroup group = new ButtonGroup();
            group.add(trueButton);
            group.add(falseButton);

            panel.add(trueButton);
            panel.add(falseButton);
        }

        @Override
        public Component getTableCellEditorComponent(JTable table, Object value,
                boolean isSelected, int row, int column) {

            if (value == null) {
                trueButton.setSelected(false);
                falseButton.setSelected(false);
            } else {
                boolean boolValue = (Boolean) value;
                trueButton.setSelected(boolValue);
                falseButton.setSelected(!boolValue);
            }

            return panel;
        }

        @Override
        public Object getCellEditorValue() {
            if (trueButton.isSelected()) {
                return true;
            } else if (falseButton.isSelected()) {
                return false;
            }
            return null;
        }
    }

    private void openConditionsManager() {
        // Cast owner to EditorWindow since we know it's EditorWindow
        if (getOwner() instanceof EditorWindow) {
            EditorWindow editorWindow = (EditorWindow) getOwner();
            ConditionsManagerDialog dialog = new ConditionsManagerDialog(editorWindow);
            dialog.setVisible(true);
            // Reload table to show new conditions
            loadExistingActions();
        }
    }
}
